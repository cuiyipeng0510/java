## 数据结构与算法

```java
常见位移 >>（除以2的指数） >>>（高位补0） <<（乘以2的指数 地位补0） | & ^
| 或运算 有 1 为1 没有为0
& 与运算 不同取0  相同不变
^ 异或运算 无进位相加

 （N &（~N）+1） N与N取反加 1
 1、提取一个int类型数最右侧的1
	0101 0011 0100 0000
取反 1010 1100 1011 1111
加1  1010 1100 1100 0000
&    0000 0000 0100 0000 
```



### 1. 链表

#### 单向链表

```java
public Class Node{
	private int value;
	private Node next;
	public Node(int data){
		this.value = data; 
	}
}
```

双向链表

```java
public Class DoubleNode{
	private int value;
	private Node pre;
	private Node next;
	public DoubleNode(int data){
		this.value = data; 
	}
}
```

### 2. 栈和队列

#### 逻辑概念

- 栈： 数据先进后出，类似水桶
- 队列： 先进先出 类似管道

```
1. 双向链表实现 栈 （头进头出，尾进尾出）
```

- 两个队列 可以辅助实现一个栈的功能
- 两个栈 可以辅助实现一个队列的功能

### 递归

- 递归本质调用的是依赖系统线程栈实现的

### 堆( Heap )

- 大根堆 每个节点的值 > 它的所有子树的值 

  - 左孩子 i * 2 + 1

  - 右孩子 i * 2 + 2

  - 父节点  左孩子 ---> i / 2  右孩子 **(i - 1) / 2**

    ```
    // 数组先看成二叉树 从右往左，先 heapaFiy 变成大根堆
    ```

    

- 小根堆 每个节点的值 < 它的所有子树的值

### 前缀树

- 实现方式
- 使用模型

### 桶



|          | 时间复杂度 | 额为空间复杂度 | 稳定性 |
| -------- | ---------- | -------------- | ------ |
| 选择排序 | O(N^2)     | O(1)           | 无     |
| 冒泡排序 | O(N^2)     | O(1)           | 有     |
| 插入排序 | O(N^2)     | O(1)           | 有     |
| 归并排序 | O(N*logN)  | O(N)           | 有     |
| 随机快排 | O(N*logN)  | O(logN)        | 无     |
| 堆排序   | O(N*logN)  | O(1)           | 无     |
| 计数排序 | O(N)       | O(M)           | 有     |
| 基数排序 | O(N)       | O(N)           | 有     |



绝对的运行时间 ： 使用 随机快排 ----->  常数项最低



### 排序方式：

- 选择排序  最小的往前走  N^2
- 冒泡排序   最大的往后走  N^2
- 插入排序   N^2
- 归并排序  合并相等 先拷贝 左边的可以有稳定性
- 快速排序 partition
- 堆排序 大根堆树上自己玩
- 桶排序思想 计数排序 & 基数排序 --- 
  -  不基于比较的排序 --- 年龄排序
  -  （十进制数） O( N * log 10 MAX)  额外空间复杂度 O(m)
  -  对数据状况有严格要求 <指定范围数字>

### 稳定性  ---- 基础数据类型不谈 稳定性，针对引用传递数据类型

- 数据排序之后，相同数字先后出现的顺序不变

1. 冒泡排序   最大的往后走
2. 插入排序  

### 不稳定排序

1. 选择排序  最小的往前走 --  选一个最小的数与前边数替换   (  55555 **1** 5555 )   





### 链表问题

1. 单链表环问题
   - HashSet 遍历添加，先查找比较，在添加节点
   - 快慢指针 
     1. 第一次相遇，快指针回到头部
     2. 双指针同步运行，再次相遇必定是第一个入环节点
2. 两个单链表，判断是否有相交节点
   1. HashSet 
      - 先把一个链表添加到 hashSet中 在查询添加另一个链表节点
   2.  