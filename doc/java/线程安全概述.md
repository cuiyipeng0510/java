### 电影院多个窗口买票

#### 线程生活案例

1. 100 张票
2. 三个窗口麦
   - 问题
     1. 多个窗口同时买同一张票
     2. 票卖完 出现 -1 0 

##### 安全问题：

​	同时处理共享数据

static 修饰的静态方法 锁关键字  **synchronized** 对应的类是 该方法所在类的 Class 对象

获取Class 对象的方式有三种：

**说明：** // （类名称全路径） 内部类路径需要用 $ 链接表示

1. Class.forName("类的全限定名")；
2. 实类对象.getClass();
3. 类名.class (类字面常量)



##### 进程与线程的区别

**进程：**内存中运行的应用程序、每个进程都有独立的内存空间

**线程：**进程中任务的执行单元 

**线程调度：** 1、分时调度  2、抢占式调度

**主线程：** 执行主方法的线程

​	java程序中只有一个线程 （**main**）

​	main方法 从上到下依次执行

##### **线程之间的通信** 等待与唤醒机制

- 等待
  1. **wait** 线程不在活动、进入 wait set 状态不会浪费CPU资源、也不会竞争锁 这时的线程状态时 waiting 。 需要调用 notify 唤醒线程重新进入调度队列 ready queue  
  2. **notify** 唤醒一个 wait set 状态的线程 （等待时间最长的？？？ 这块有疑问） 餐馆就餐、等最久的顾客优先（应该有vip权限）
  3. **notifyAll** 唤醒所有 wait set 状态的线程 
- **备注：**
  1. 这三个方法属于 **Object** 类中方法。所有类都是 Object 类的子类、所以所有类都有这几个方法
  2. wait 与 notify 方法必须由同一个锁对象调用 
  3. 必须在同步代码块、或者同步函数中使用、因为必须要通过锁对象调用者两个方法

##### **线程状态概述**

| 状态名称      | 状态描述                                                     |
| ------------- | ------------------------------------------------------------ |
| new           | 新建状态 （**new Therad（）**; ）                            |
| Runnable      | 运行状态                                                     |
| blocked       | 阻塞状态 （线程抢夺cpu执行权）                               |
| timed_waiting | 定时等待（睡觉了）、时间到了自然醒 **sleep(long)、 wait(long)** |
| waiting       | 永久等待 **writ()** 、需要出发唤醒机制（**notify、notifyAll**） |
| terminated    | **run()** 方法执行完毕或程序异常、线程终止                   |

#### 线程池

**1. 概念：** 容纳多个线程的容器、其中线程可以反复使用、避免了重复创建销毁造成的cpu损耗、提高资源利用率

​		**容器 ---> 集合 （ArrayList、HashSet、LinkedList、HashMap）**

**2. 合理利用线程池的好处: **

1. 降低资源消耗、减少创建销毁次数、可重复利用

2. 提高响应速度、随时可用

3. 提高线程的可管理行、可根据系统能力适当配置线程数目（每个线程大约占 **1MB** 内存）

   ##### 

程序第一次启动的时候、创建多个线程、保存在一个集合对象中、当我们想用的时候从集合中取、使用完毕后重新归还到集合对象中 

![image-20200807005959475](D:\工具\Typora\document\images\线程池运行图解.png)



**3.创建线程池方式**

说明：jdk1.5 之后提供的 java.util.concurrent.Executors: 线程池的工程类

```java
/**
 * Executors 中提供了很多静态方法创建线程池
 * 使用线程池的步骤：
 *  1. 创建一个线程池 Executors.newFixedThreadPool
 *  2. 创建一个对象实现 Runnable 接口
 *  3. 使用线程对象的 submit 方法提交一个线程任务
 *  4. shutdown 销毁线程池、慎重使用
 *
 */
public class DemoExecutorPool {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(2);
        ThreadRunnable tr = new ThreadRunnable();
        executorService.submit(tr);
        executorService.submit(tr);
        executorService.submit(tr);

        // 手动创建的线程 start 方法执行完毕、调用 stop() 或者 程序异常，该线程就会进入终止状态
        // 手动创建的线程、 一个线程 只能调用一次 start() 方法
//        Thread th = new Thread(tr);
//        th.start();
//        th.start();

    }

    public static class ThreadRunnable implements Runnable{

        @Override
        public void run() {
            System.out.println(Thread.currentThread().getName()+ "哇哈哈哈的线程");
        }
    }
}
```



![image-20200812235942977](D:\工具\Typora\document\images\线程状态图.png)



线程锁：

```java
synchronized （）{ }  //单独锁
Lock lock = new ReentrantLock();  // 可重复锁
Condition conditon1 = lock.newCondition();
Condition conditon2 = lock.newCondition();

//自旋锁 1. 定义枚举、2. 设置循环条件 
while (true){}
```

线程通信：

```java
//唤醒某个线程进入
LockSupport.unpark(new Thread);
//线程阻塞、进入等待状态
LockSupport.park();

// 随机唤醒某个线程
notify()
// 当前线程进入阻塞状态
wait();
```



![image-20200813001706693](D:\工具\Typora\document\images\线程知识图谱.png)



自旋锁核心：
	AtomicInteger： incerementAndGet  自旋锁（CAS）
	底层原理、  lock cmpxchg 指令  C++ 底层指令 锁定总线
	

	jvm  1:1
	
	操作系统调用、操作锁（重量级锁）
	juc用户空间（轻量级锁）
		问题：ABA 加版本号控制
			  CAS 


​			  
	偏向锁：--->严格讲不是锁 
		1. 厕所门上 贴名（过来就是你的---）
		2. 别人来了 锁升级   偏向锁 ---> 自旋锁
		
		优化 synchronized 标注的类方法


​		
		轻量级锁 ---> 升级 重量级锁
		
		判断自旋次数、  达标进队列