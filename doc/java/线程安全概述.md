### 线程数计算公式

**N(线程数) = N(cpu) * U(cpu) * (1 + W/C)**

- N(cpu) 是处理器的核数， Runtime.getRuntime().availableProcessors() 得到
- U(cpu) 期望的CPU 利用率 （0，1）
- W/C 等待时间与计算时间比率

Profiler 测试工具

1. 单核CPU设定线程是否由意义
2. 工作线程数是不是设置越大越好
3. 工作线程数设置多少合适 （计算 W/C 比率工具 JProfiler）

### 电影院多个窗口买票

#### 线程生活案例

1. 100 张票
2. 三个窗口麦
   - 问题
     1. 多个窗口同时买同一张票
     2. 票卖完 出现 -1 0 

##### 安全问题：

​	同时处理共享数据

static 修饰的静态方法 锁关键字  **synchronized** 对应的类是 该方法所在类的 Class 对象

获取Class 对象的方式有三种：

**说明：** // （类名称全路径） 内部类路径需要用 $ 链接表示

1. Class.forName("类的全限定名")；
2. 实类对象.getClass();
3. 类名.class (类字面常量)



##### 进程与线程的区别

**进程：**内存中运行的应用程序、每个进程都有独立的内存空间

**线程：**进程中任务的执行单元 

**线程调度：** 1、分时调度  2、抢占式调度

**主线程：** 执行主方法的线程

​	java程序中只有一个线程 （**main**）

​	main方法 从上到下依次执行

##### **线程之间的通信** 等待与唤醒机制

- 等待
  1. **wait** 线程不在活动、进入 wait set 状态不会浪费CPU资源、也不会竞争锁 这时的线程状态时 waiting 。 需要调用 notify 唤醒线程重新进入调度队列 ready queue  
  2. **notify** 唤醒一个 wait set 状态的线程 （等待时间最长的？？？ 这块有疑问） 餐馆就餐、等最久的顾客优先（应该有vip权限）
  3. **notifyAll** 唤醒所有 wait set 状态的线程 
- **备注：**
  1. 这三个方法属于 **Object** 类中方法。所有类都是 Object 类的子类、所以所有类都有这几个方法
  2. wait 与 notify 方法必须由同一个锁对象调用 
  3. 必须在同步代码块、或者同步函数中使用、因为必须要通过锁对象调用者两个方法

##### **线程状态概述**

| 状态名称      | 状态描述                                                     |
| ------------- | ------------------------------------------------------------ |
| new           | 新建状态 （**new Therad（）**; ）                            |
| Runnable      | 运行状态                                                     |
| blocked       | 阻塞状态 （线程抢夺cpu执行权）                               |
| timed_waiting | 定时等待（睡觉了）、时间到了自然醒 **sleep(long)、 wait(long)** |
| waiting       | 永久等待 **writ()** 、需要出发唤醒机制（**notify、notifyAll**） |
| terminated    | **run()** 方法执行完毕或程序异常、线程终止                   |

#### 线程池

**1. 概念：** 容纳多个线程的容器、其中线程可以反复使用、避免了重复创建销毁造成的cpu损耗、提高资源利用率

​		**容器 ---> 集合 （ArrayList、HashSet、LinkedList、HashMap）**

**2. 合理利用线程池的好处: **

1. 降低资源消耗、减少创建销毁次数、可重复利用

2. 提高响应速度、随时可用

3. 提高线程的可管理行、可根据系统能力适当配置线程数目（每个线程大约占 **1MB** 内存）

   ##### 

程序第一次启动的时候、创建多个线程、保存在一个集合对象中、当我们想用的时候从集合中取、使用完毕后重新归还到集合对象中 

![image-20200807005959475](images\线程池运行图解.png)



**3.创建线程池方式**

说明：jdk1.5 之后提供的 java.util.concurrent.Executors: 线程池的工程类

```java
/**
 * Executors 中提供了很多静态方法创建线程池
 * 使用线程池的步骤：
 *  1. 创建一个线程池 Executors.newFixedThreadPool
 *  2. 创建一个对象实现 Runnable 接口
 *  3. 使用线程对象的 submit 方法提交一个线程任务
 *  4. shutdown 销毁线程池、慎重使用
 *
 */
public class DemoExecutorPool {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(2);
        ThreadRunnable tr = new ThreadRunnable();
        executorService.submit(tr);
        executorService.submit(tr);
        executorService.submit(tr);

        // 手动创建的线程 start 方法执行完毕、调用 stop() 或者 程序异常，该线程就会进入终止状态
        // 手动创建的线程、 一个线程 只能调用一次 start() 方法
//        Thread th = new Thread(tr);
//        th.start();
//        th.start();

    }

    public static class ThreadRunnable implements Runnable{

        @Override
        public void run() {
            System.out.println(Thread.currentThread().getName()+ "哇哈哈哈的线程");
        }
    }
}
```



![image-20200812235942977](images\线程状态图.png)

## **初始态：NEW**

创建一个Thread对象，但还未调用start()启动线程时，线程处于初始态。

## **运行态：RUNNABLE**

在Java中，运行态包括就绪态 和 运行态。

- 就绪态  

- - 该状态下的线程已经获得执行所需的所有资源，只要CPU分配执行权就能运行。
  - 所有就绪态的线程存放在就绪队列中。

- 运行态  

- - 获得CPU执行权，正在执行的线程。
  - 由于一个CPU同一时刻只能执行一条线程，因此每个CPU每个时刻只有一条运行态的线程。

## **阻塞态**

- 当一条正在执行的线程请求某一资源失败时，就会进入阻塞态。
- 而在Java中，阻塞态专指请求锁失败时进入的状态。
- 由一个阻塞队列存放所有阻塞态的线程。
- 处于阻塞态的线程会不断请求资源，一旦请求成功，就会进入就绪队列，等待执行。

PS：锁、IO、Socket等都资源。

## **等待态**

- 当前线程中调用wait、join、park函数时，当前线程就会进入等待态。
- 也有一个等待队列存放所有等待态的线程。
- 线程处于等待态表示它需要等待其他线程的指示才能继续运行。
- 进入等待态的线程会释放CPU执行权，并释放资源（如：锁）

## **超时等待态**

- 当运行中的线程调用sleep(time)、wait、join、parkNanos、parkUntil时，就会进入该状态；
- 它和等待态一样，并不是因为请求不到资源，而是主动进入，并且进入后需要其他线程唤醒；
- 进入该状态后释放CPU执行权 和 占有的资源。
- **与等待态的区别：**到了超时时间后自动进入阻塞队列，开始竞争锁。

## **终止态**

线程执行结束后的状态。



线程锁：

```java
synchronized （）{ }  //单独锁
Lock lock = new ReentrantLock();  // 可重复锁
Condition conditon1 = lock.newCondition();
Condition conditon2 = lock.newCondition();

//自旋锁 1. 定义枚举、2. 设置循环条件 
while (true){}
```

线程通信：

```java
//唤醒某个线程进入
LockSupport.unpark(new Thread);
//线程阻塞、进入等待状态
LockSupport.park();

// 随机唤醒某个线程
notify()
// 当前线程进入阻塞状态
wait();
```



![image-20200813001706693](images\线程知识图谱.png)



自旋锁核心：
	AtomicInteger： incerementAndGet  自旋锁（CAS）
	底层原理、  lock cmpxchg 指令  C++ 底层指令 锁定总线
	

	jvm  1:1
	
	操作系统调用、操作锁（重量级锁）
	juc用户空间（轻量级锁）
		问题：ABA 加版本号控制
			  CAS 


​	偏向锁：--->严格讲不是锁 
		1. 厕所门上 贴名（过来就是你的---）
		2. 别人来了 锁升级   偏向锁 ---> 自旋锁
		

		优化 synchronized 标注的类方法


​		
​		轻量级锁 ---> 升级 重量级锁
​		

		判断自旋次数、  达标进队列

#### 线程中断

1. interrupt  // 设置中断标记
2. isterrupted // 查询中断标记位
3. static interrupted // 查询当前线程是否被设置过中断标记位，并重置标记位置 false

```java
public void interrupt() {
    if (this != Thread.currentThread())
    checkAccess();

    synchronized (blockerLock) {
    Interruptible b = blocker;
        if (b != null) {
            interrupt0();           // Just to set the interrupt flag
            b.interrupt(this);
            return;
        }
    }
    interrupt0();
}

public boolean isInterrupted() {
	return isInterrupted(false);
}

public static boolean interrupted() {
	return currentThread().isInterrupted(true);
}
```

